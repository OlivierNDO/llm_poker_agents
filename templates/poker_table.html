<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Poker Table - Glass Effect</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #f8fafc 0%, #e0f2fe 40%, #d9f99d 100%);
            color: #1f2937;
            min-height: 100vh;
            padding: 20px;
        }

        .poker-container {
            max-width: 2000px;
            width: 95vw;
            margin: 0 auto;
            padding: 0 10px;
        }

        .table-area {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            box-shadow: 
                0 8px 32px rgba(31, 38, 135, 0.37),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .board-section {
            text-align: center;
            margin-bottom: 40px;
        }

        .board-title {
            font-size: 18px;
            color: #FFD700;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .board-cards {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        /* Container for side-by-side reasoning boxes */
        .reasoning-row {
            display: flex;
            gap: 12px;
            margin-top: 12px;
        }

        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(550px, 1fr));
            gap: 20px;
            max-width: none;
            margin: 0 auto;
            justify-items: center;
        }

        /* IMPROVED GLASS EFFECT FOR PLAYER CARDS */
        .player-card {
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            width: min(100%, 650px);
            padding: 20px;
            border-radius: 20px;
            overflow: hidden;
            
            /* Glass background with proper transparency */
            background: rgba(255, 255, 255, 0.08);
            
            /* Critical: border needs to be more visible */
            border: 1px solid rgba(255, 255, 255, 0.3);
            
            /* Enhanced backdrop filter */
            backdrop-filter: blur(16px) saturate(200%) contrast(120%) brightness(110%);
            -webkit-backdrop-filter: blur(16px) saturate(200%) contrast(120%) brightness(110%);
            
            /* Better shadow for depth */
            box-shadow: 
                0 8px 32px rgba(31, 38, 135, 0.37),
                inset 0 1px 0 rgba(255, 255, 255, 0.5),
                inset 0 -1px 0 rgba(255, 255, 255, 0.2);
            
            color: #1f2937;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        /* Glass reflection effect */
        .player-card::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(
                to bottom,
                rgba(255, 255, 255, 0.3) 0%,
                rgba(255, 255, 255, 0.1) 50%,
                transparent 100%
            );
            border-radius: 20px 20px 0 0;
            pointer-events: none;
            z-index: 1;
        }

        /* Ensure content is above the glass effects */
        .player-card > * {
            position: relative;
            z-index: 2;
        }

        /* Hover effect */
        .player-card:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 12px 40px rgba(31, 38, 135, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.6),
                inset 0 -1px 0 rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.4);
        }

        /* Active state */
        .player-card.active {
            border-color: rgba(255, 255, 255, 0.45);
            box-shadow: 
                0 8px 32px rgba(31, 38, 135, 0.45),
                inset 0 1px 0 rgba(255, 255, 255, 0.6),
                inset 0 -1px 0 rgba(255, 255, 255, 0.25);
        }
        
        /* Pulse the current player's NAME when it's their turn */
        .player-card.active .player-name {
          animation: namePulse 900ms ease-in-out infinite;
          will-change: transform, text-shadow;
          transform-origin: center;
        }
        
        
        /* Uses current text color so it matches each player's chip color tint */
        @keyframes namePulse {
          0%, 100% {
            transform: scale(1);
            text-shadow: 0 0 0 currentColor;
          }
          50% {
            transform: scale(1.06);
            text-shadow: 0 0 16px currentColor;
          }
        }
        
        /* Respect reduced-motion preferences */
        @media (prefers-reduced-motion: reduce) {
          .player-card.active .player-name {
            animation: none;
          }
        }

        /* Folded state */
        .player-card.folded {
            filter: grayscale(0.8) opacity(0.5);
            background: rgba(255, 255, 255, 0.02);
            transform: scale(0.95);
            border-color: rgba(255, 255, 255, 0.15);
        }
        
        .player-card.folded .player-name {
            opacity: 0.6;
        }
        
        .player-card.folded .chip-count {
            opacity: 0.5;
        }
        
        .player-card.folded .last-action-display {
            opacity: 0.8;
        }
        
        .player-card.folded .player-reasoning {
            opacity: 0.4;
        }


        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .player-name {
            font-weight: 700; /* Apple uses 700 weight frequently */
            font-size: 24px;
            color: #424245; /* Medium gray - easier on the eyes */
            text-shadow: 0 0.5px 1px rgba(255, 255, 255, 0.6);
        }

        .dealer-indicator {
            background: rgba(59, 130, 246, 0.2);
            color: #1e40af;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            border: 1px solid rgba(59, 130, 246, 0.4);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            box-shadow: 0 2px 8px rgba(31, 38, 135, 0.3);
        }
        
        .chip-count-display {
            display: flex;
            justify-content: center;
            margin-bottom: 8px;
        }


        .chip-number {
            text-align: center;
            color: #1e40af;
            font-weight: 800;
            font-size: 22px;
            margin-top: 8px;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }
        

        .chip-count {
            background: rgba(255, 255, 255, 0.15);
            color: #1f2937;
            border-radius: 10px;
            font-weight: bold;
            font-size: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            text-align: center;
            width: var(--chip-count-width, 80px);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 10px 16px;
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            box-shadow: 
                0 2px 8px rgba(31, 38, 135, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }

        .pot-display {
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            padding: 16px 32px;
            margin: 0 auto 25px auto;
            width: fit-content;
            text-align: center;
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            box-shadow: 
                0 4px 16px rgba(31, 38, 135, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }
                
        .pot-label {
            font-size: 14px;
            color: #374151;
            font-weight: 600;
            letter-spacing: 1px;
            margin-bottom: 4px;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }
        
        .pot-value {
            font-size: 28px;
            color: #111827;
            font-weight: bold;
            line-height: 1;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }

        .flash-change {
            animation: flash 450ms ease;
        }
        
        @keyframes flash {
            0% { background: rgba(255, 255, 255, 0.25); }
            100% { background: transparent; }
        }

        .player-cards {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .action-info-row {
            display: flex;
            gap: 12px;
            margin-bottom: 15px;
            align-items: center;
        }
        
        /* Action box — betting/status */
        .action-box {
            flex: 1;
            min-width: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        
            padding: 10px 14px;
            min-height: 40px;
        
            font-weight: 600;
            font-size: 13px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: #111827;
        
            /* glass style aligned with chip-count/cards */
            background: rgba(255, 255, 255, 0.22);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 12px;
        
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
        
            box-shadow:
                0 4px 12px rgba(2, 6, 23, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
        }
        
        /* Hand strength box */
        .hand-box {
            flex: 1;
            min-width: 0;
        
            display: flex;
            align-items: center;
            justify-content: center;
        
            padding: 8px 12px;
            height: 36px;
        
            font-weight: 700;
            font-size: 13px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: #111827;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        
            /* match chip-count/cards */
            background: rgba(255, 255, 255, 0.22);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 12px;
        
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
        
            box-shadow:
                0 4px 12px rgba(2, 6, 23, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
        }
        
        .hand-box:empty::before {
            content: '\00A0'; /* Non-breaking space to maintain height */
            opacity: 0;
        }
        
        .player-reasoning {
            margin-top: 12px;
            min-height: 290px;
            max-height: 290px;
            padding: 12px;
            
            background: rgba(255, 255, 255, 0.22);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            
            box-shadow:
                0 4px 12px rgba(2, 6, 23, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
            
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .reasoning-label {
            font-size: 18px; /* Increased from 11px */
            font-weight: 600;
            color: #374151;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
        }

        /* Individual reason bubbles */
        .reason-bubble {
            display: inline-block;
            margin: 4px 6px 4px 0;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 18px;
            font-weight: 600;
            line-height: 1.3;
            max-width: 100%;
            word-wrap: break-word;
            
            /* Base bubble styling with better contrast */
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.6);
            color: #1e293b;
            
            backdrop-filter: blur(8px) saturate(150%);
            -webkit-backdrop-filter: blur(8px) saturate(150%);
            
            box-shadow: 
                0 2px 8px rgba(31, 38, 135, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            
            transition: all 0.2s ease;
        }

        .reason-bubble:hover {
            transform: translateY(-1px);
            box-shadow: 
                0 4px 12px rgba(31, 38, 135, 0.35),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
        }

        /* Alternating bubble styles for visual separation */
        .reason-bubble:nth-child(odd) {
            background: rgba(255, 255, 255, 0.9);
            border-color: rgba(255, 255, 255, 0.7);
            color: #1e293b;
        }

        .reason-bubble:nth-child(even) {
            background: rgba(248, 250, 252, 0.9);
            border-color: rgba(226, 232, 240, 0.7);
            color: #334155;
        }

        @keyframes bubbleAppear {
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }


        /* Disable animations if user prefers reduced motion */
        @media (prefers-reduced-motion: reduce) {
            .reason-bubble {
                animation: none;
                opacity: 1;
                transform: none;
            }
        }

        /* Empty state */
        .reasoning-empty {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #64748b;
            font-style: italic;
            font-size: 14px;
        }

        /* Playing cards with glass effect */
        .card {
            /* Change from 65px x 90px to board card size */
            width: 85px;
            height: 115px;
            position: relative;
            border-radius: 12px;
            padding: 8px 6px; /* Adjust padding for larger size */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            
            background: rgba(255, 255, 255, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(10px) saturate(150%);
            -webkit-backdrop-filter: blur(10px) saturate(150%);
            box-shadow: 
                0 4px 12px rgba(31, 38, 135, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
            
            color: #0f172a;
            font-weight: 800;
            font-size: 20px; /* Increase font size to match board cards */
        }
        
        .card.red {
            color: #dc2626;
        }

        .card .rank {
            font-size: 24px;
            font-weight: 900;
            line-height: 1;
        }

        .card .suit {
            font-size: 26px;
            line-height: 1;
            margin-top: -4px;
        }

        .card.back {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(8px) saturate(120%);
            -webkit-backdrop-filter: blur(8px) saturate(120%);
            background-image: 
                repeating-linear-gradient(45deg, rgba(255,255,255,.15) 0px, rgba(255,255,255,.15) 2px, transparent 2px, transparent 4px),
                repeating-linear-gradient(-45deg, rgba(255,255,255,.1) 0px, rgba(255,255,255,.1) 2px, transparent 2px, transparent 4px);
        }

        .board-card {
            width: 85px;
            height: 115px;
        }

        .board-card .rank {
            font-size: 24px;
        }

        .board-card .suit {
            font-size: 26px;
        }

        .controls {
            text-align: center;
            margin: 30px 0;
        }

        .btn {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #2563eb;
            font-weight: 600;
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            transition: all 0.2s ease;
            box-shadow: 
                0 2px 8px rgba(31, 38, 135, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }
        
        .btn:hover {
            background: rgba(255, 255, 255, 0.22);
            box-shadow: 
                0 4px 16px rgba(31, 38, 135, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .action-log {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            box-shadow: 
                0 6px 20px rgba(31, 38, 135, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }
        
        .action-log h3 {
            color: #2563eb;
            margin-bottom: 15px;
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }
        
        .log-entry {
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 10px 14px;
            margin: 6px 0;
            font-size: 14px;
            color: #334155;
            backdrop-filter: blur(8px) saturate(160%);
            -webkit-backdrop-filter: blur(8px) saturate(160%);
            box-shadow: 
                0 2px 6px rgba(31, 38, 135, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .loading {
            text-align: center;
            font-size: 18px;
            color: #FFD700;
            margin: 10px 0;
        }

        .error {
            background: rgba(239, 68, 68, 0.2);
            color: #dc2626;
            padding: 15px;
            border-radius: 12px;
            margin: 15px 0;
            text-align: center;
            border: 1px solid rgba(239, 68, 68, 0.3);
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            box-shadow: 
                0 4px 12px rgba(239, 68, 68, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .players-grid {
                grid-template-columns: 1fr;
            }
            
            .pot-info {
                flex-direction: column;
                gap: 15px;
            }
            
            .player-header {
                flex-direction: column;
                align-items: flex-start;
            }
        }

        /* Fallback for browsers without backdrop-filter */
        @supports not ((-webkit-backdrop-filter: blur(1px)) or (backdrop-filter: blur(1px))) {
            .player-card {
                background: rgba(255, 255, 255, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.9);
            }
            
            .table-area {
                background: rgba(255, 255, 255, 0.7);
            }
            
            .pot-display,
            .action-box,
            .hand-box,
            .player-reasoning,
            .chip-count,
            .action-log {
                background: rgba(255, 255, 255, 0.7);
                border: 1px solid rgba(255, 255, 255, 0.8);
            }
        }
        
        /***** Chip stack visuals (embedded from standalone) *****/
        :root {
          --chip-width: 50px;
          --chip-height: 4px;
          --chip-spacing: 3px;
          --max-stack-height: 40;
        }
        
        .stacks-grid {
          display: flex;
          gap: 8px;
          justify-content: center;
          align-items: flex-end;
          min-height: calc(var(--max-stack-height) * var(--chip-spacing) + 30px);
          padding: 0 6px;
          margin-top: 10px;
        }
        
        .chip-stack {
          position: relative;
          width: var(--chip-width);
          height: calc(var(--max-stack-height) * var(--chip-spacing) + 20px);
          display: flex;
          align-items: flex-end;
          justify-content: center;
        }
        
        .stack-column {
          position: relative;
          width: var(--chip-width);
          height: 100%;
          filter: drop-shadow(0 6px 12px rgba(0,0,0,0.4));
        }
        
        .chip {
          position: absolute;
          left: 0;
          width: var(--chip-width);
          height: var(--chip-height);
          border-radius: 2px;
          transition: all 0.5s cubic-bezier(0.4,0,0.2,1);
          transform-origin: center bottom;
          opacity: 0;
          transform: translateY(10px) scaleY(0.5);
          /* box-shadow: 0 1px 2px rgba(0,0,0,0.6), inset 0 1px 1px rgba(255,255,255,0.3); */
        }
        .chip.visible { opacity: 1; transform: translateY(0) scaleY(1); }
        .chip.removing { opacity: 0; transform: translateY(10px) scaleY(0.5); }
        
        /* colors */
        .chip.blue   { background: linear-gradient(to bottom,#60a5fa 0%,#3b82f6 20%,#1e40af 50%,#3b82f6 80%,#60a5fa 100%); }
        .chip.red    { background: linear-gradient(to bottom,#f87171 0%,#ef4444 20%,#b91c1c 50%,#ef4444 80%,#f87171 100%); }
        .chip.green  { background: linear-gradient(to bottom,#4ade80 0%,#22c55e 20%,#15803d 50%,#22c55e 80%,#4ade80 100%); }
        .chip.purple { background: linear-gradient(to bottom,#c084fc 0%,#a855f7 20%,#7c3aed 50%,#a855f7 80%,#c084fc 100%); }
        .chip.orange { background: linear-gradient(to bottom,#fb923c 0%,#f97316 20%,#c2410c 50%,#f97316 80%,#fb923c 100%); }
        
        .chip.navy { 
            background: 
                radial-gradient(circle at center, transparent 30%, rgba(255,255,255,0.2) 35%, transparent 40%),
                radial-gradient(circle at center, transparent 60%, rgba(255,255,255,0.1) 65%, transparent 70%),
                linear-gradient(to bottom, #60a5fa 0%, #3b82f6 20%, #1e40af 50%, #3b82f6 80%, #60a5fa 100%);
        }
        
        /* Last Action Display Box */
        .last-action-display {
            margin-top: 12px;
            padding: 14px 18px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 18px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            
            background: rgba(255, 255, 255, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            box-shadow:
                0 4px 12px rgba(2, 6, 23, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
        }
        
        /* Action type colors */
        .last-action-display.fold {
            background: rgba(107, 114, 128, 0.3);
            border-color: rgba(107, 114, 128, 0.5);
            color: #374151;
        }
        
        .last-action-display.check {
            background: rgba(34, 197, 94, 0.25);
            border-color: rgba(34, 197, 94, 0.4);
            color: #166534;
        }
        
        .last-action-display.call {
            background: rgba(59, 130, 246, 0.25);
            border-color: rgba(59, 130, 246, 0.4);
            color: #1e40af;
        }
        
        .last-action-display.bet, .last-action-display.raise {
            background: rgba(239, 68, 68, 0.25);
            border-color: rgba(239, 68, 68, 0.4);
            color: #b91c1c;
        }
        
        .last-action-display.waiting {
            background: rgba(156, 163, 175, 0.2);
            border-color: rgba(156, 163, 175, 0.3);
            color: #6b7280;
            font-style: italic;
            text-transform: none;
        }
        
        .planning-reasoning, .player-reasoning {
            flex: 1;
            margin-top: 0;
            margin-bottom: 0;
            min-height: 450px; /* Doubled from 320px */
            max-height: 450px;
            padding: 16px;
            
            background: rgba(255, 255, 255, 0.18);
            border: 1px solid rgba(255, 255, 255, 0.35);
            border-radius: 12px;
            
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            
            box-shadow:
                0 4px 12px rgba(2, 6, 23, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
            
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        /* Increase gap between the two boxes */
        .reasoning-row {
            display: flex;
            gap: 16px; /* Increased from 12px */
            margin-top: 12px;
        }
        


        @media (max-width: 768px) {
            .reasoning-row {
                flex-direction: column;
                gap: 12px;
            }
            
            .players-grid {
                grid-template-columns: 1fr;
            }
            
            .player-card {
                width: min(100%, 500px);
            }
            
            .planning-reasoning, .player-reasoning {
                min-height: 450px; /* Doubled from 250px */
                max-height: 450px;
            }
        }
        
        
        /* Utility Analysis Panel */
        .utility-panel {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 1000;
        }
        
        .utility-box {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 16px;
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            box-shadow: 
                0 8px 32px rgba(31, 38, 135, 0.37),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            min-height: 120px;
            max-height: 250px;
        }
        
        .utility-header {
            font-size: 16px;
            font-weight: 700;
            color: #2563eb;
            margin-bottom: 10px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }
        
        .utility-content {
            font-size: 13px;
            color: #1f2937;
            line-height: 1.4;
            overflow-y: auto;
            overflow-x: hidden;
            max-height: 200px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .utility-content:empty::before {
            content: 'Waiting...';
            color: #64748b;
            font-style: italic;
        }
        
        /* Hide on mobile */
        @media (max-width: 768px) {
            .utility-panel {
                display: none;
            }
        }
                                
                        
        
        
    </style>
</head>
<body>
    <div class="poker-container">
        <div class="error" id="errorMessage" style="display: none;"></div>

        <div class="table-area">
            <div class="board-section">
                <div class="pot-display">
                    <div class="pot-label">POT</div>
                    <div class="pot-value">$<span id="potAmount">0</span></div>
                </div>
                
                <div class="board-cards" id="boardCards">
                    <!-- Community cards will be added here -->
                </div>
            </div>

            <div class="players-grid" id="playersGrid">
                <!-- Player cards will be dynamically added here -->
            </div>
        </div>
        
        <!-- Utility Analysis Panel -->
        <div class="utility-panel">
            <div class="utility-box" id="hand-analysis-box">
                <div class="utility-header">Hand Analysis</div>
                <div class="utility-content" id="hand-analysis-content">
                    Waiting for analysis...
                </div>
            </div>
            
            <div class="utility-box" id="monte-carlo-box">
                <div class="utility-header">Monte Carlo</div>
                <div class="utility-content" id="monte-carlo-content">
                    Waiting for simulation...
                </div>
            </div>
            
            <div class="utility-box" id="opponent-stats-box">
                <div class="utility-header">Opponent Stats</div>
                <div class="utility-content" id="opponent-stats-content">
                    Waiting for stats...
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn" id="startHandBtn" onclick="startNewHand()">Start New Hand</button>
            <button class="btn" id="nextActionBtn" onclick="nextAction()" style="display: none;">Next Action</button>
            <!-- auto play -->
            <button class="btn" id="autoPlayBtn" onclick="autoPlay()" style="display: none;">Auto Play</button>
            <button class="btn" id="stopAutoBtn" onclick="stopAutoPlay()" style="display: none;">Stop</button>
            <button class="btn" id="resetGameBtn" onclick="resetGame()">Reset Game</button>
        </div>

        <div class="action-log">
            <h3>Game Log</h3>
            <div id="actionLog">
                <div class="log-entry">Ready to start - click "Start New Hand"</div>
                <div class="log-entry">Glass effect demonstration active</div>
            </div>
        </div>
    </div>

    <script>
        let gameState = null;
        let actionLog = [];
        let isProcessing = false;
        let isAutoPlaying = false;
        let autoPlayInterval = null;
        
        const initialChips = new Map();   // one and only declaration
        let totalInitialChips = 0;        // one and only declaration
        const playerChipUI = new Map();   // one and only declaration
        
        function createReasoningBubbles(reasoning) {
            if (!reasoning || reasoning.trim() === '' || reasoning === '&nbsp;') {
                return '<div class="reasoning-empty">Waiting for decision...</div>';
            }
            
            // Split only on period+space, exclamation+space, question+space (actual sentence endings)
            const reasons = reasoning.split(/[.!?]+\s+/).map(r => r.trim()).filter(r => r.length > 0);
            
            if (reasons.length === 0) {
                return '<div class="reasoning-empty">Waiting for decision...</div>';
            }
            
            // Take only the last 4 reasons
            const recentReasons = reasons.slice(-4);
            
            return recentReasons.map((reason, index) => {
                // Clean up emoji prefixes if they exist, but don't use them for styling
                let cleanReason = reason
                    .replace(/^[🎯📊💭🎭💰]\s*/, '') // Remove emoji prefixes
                    .trim();
                
                // Ensure reason ends with punctuation
                if (cleanReason && !cleanReason.match(/[.!?]$/)) {
                    cleanReason += '.';
                }
                
                return `<span class="reason-bubble">${cleanReason}</span>`;
            }).join('');
        }

        function createCard(cardStr, isBoard = false) {
            const card = document.createElement('div');
            card.className = isBoard ? 'card board-card' : 'card';
            
            if (!cardStr || cardStr === '??' || cardStr === '') {
                card.className += ' back';
                return card;
            }
            
            let rank = cardStr[0];
            if (rank === 'T') {
                rank = '10';
            }
            const suit = cardStr[1].toLowerCase();
            
            if (suit === 'h' || suit === 'd') {
                card.classList.add('red');
            }
            
            const suitSymbols = {
                'c': '♣',
                'd': '♦', 
                'h': '♥',
                's': '♠'
            };
            
            card.innerHTML = `
                <div class="rank">${rank}</div>
                <div class="suit">${suitSymbols[suit] || suit}</div>
            `;
            
            return card;
        }

        function createPlayerCard(player, index, isDealer = false, gameState = null) {
            const playerCard = document.createElement('div');
            playerCard.className = 'player-card';
            playerCard.id = `player-${index}`;
        
            if (!player.active) {
                playerCard.classList.add('folded');
            } else if (player.isCurrentPlayer) {
                playerCard.classList.add('active');
            }
        
            const dealerIndicator = isDealer ? '<div class="dealer-indicator">D</div>' : '';
        
            let cardsHtml = '';
            if (player.cards && player.cards.length > 0) {
                player.cards.forEach(card => {
                    const cardElement = createCard(card);
                    cardsHtml += cardElement.outerHTML;
                });
            }
                    
            const reasoningBubbles = createReasoningBubbles(player.reasoning || '');
            const planningBubbles = createReasoningBubbles(player.planning || ''); // NEW
        
            playerCard.innerHTML = `
                <div class="player-header">
                    <div>
                        <div class="player-name">${player.name}</div>
                    </div>
                    ${dealerIndicator}
                </div>
        
                <div class="player-cards">${cardsHtml}</div>
        
                <div class="action-info-row">
                    <div class="hand-box">${player.hand || ''}</div>
                </div>
                
                <div class="reasoning-row">
                  <div class="planning-reasoning">
                    <div class="reasoning-label">Planning:</div>
                    ${planningBubbles}
                  </div>
                
                  <div class="player-reasoning">
                    <div class="reasoning-label">Decision:</div>
                    ${reasoningBubbles}
                  </div>
                </div>
                             
                <div class="last-action-display waiting" id="action-display-${index}">
                  Waiting for action...
                </div>
                
                <div class="chip-number"><span class="chip-count__num">${player.chips}</span></div>
            `;
        
            return playerCard;
        }


        function animateNumber(el, to) {
            const from = Number(el.textContent || 0);
            if (from === to) return;
            const start = performance.now();
            const dur = 300;

            function step(t) {
                const k = Math.min(1, (t - start) / dur);
                const val = Math.round(from + (to - from) * k);
                el.textContent = val;
                if (k < 1) requestAnimationFrame(step);
            }
            el.classList.add('flash-change');
            setTimeout(() => el.classList.remove('flash-change'), 350);
            requestAnimationFrame(step);
        }
        
        function ensureInitials(state) {
            if (!state?.players) return;
            let changed = false;
            state.players.forEach(p => {
                if (!initialChips.has(p.name)) {
                    initialChips.set(p.name, p.chips);
                    changed = true;
                }
            });
            if (changed) {
                totalInitialChips = [...initialChips.values()].reduce((a,b)=>a+b, 0);
            }
        }
        
        // Use a single denominator for all players to ensure consistent scaling
        function getGlobalChipDenominator() {
            if (initialChips.size === 0) return 1;
            
            // Use the typical starting stack to compute denominator
            // This ensures all players with same starting chips have same visual scaling
            const startingStacks = [...initialChips.values()];
            const typicalStack = Math.max(...startingStacks); // Use largest starting stack as reference
            
            // Make ~120 chips at the reference stack size
            return Math.max(1, Math.round(typicalStack / 120));
        }
        
        function updateBars(state) {
           const potFill = document.getElementById('potBarFill');
           if (potFill && totalInitialChips > 0) {
               const pct = Math.max(0, Math.min(1, state.pot / totalInitialChips));
               potFill.style.width = (pct * 100).toFixed(1) + '%';
           }

           if (!state?.players) return;
           state.players.forEach((p, idx) => {
               const numEl = document.querySelector(`#player-${idx} .chip-count__num`);
               if (numEl) {
                   animateNumber(numEl, p.chips);
               }
           });
        }
        
        /* === Chip animation engine (no randomness) === */
        class ChipStack {
          constructor(stackElement, color) {
            this.el = stackElement;
            this.color = color;
            this.count = 0;
            this.chips = [];
          }
          setChipCount(n, animated = true) {
            const target = Math.max(0, Math.min(n, 40));
            if (target > this.count) {
              for (let i = this.count; i < target; i++) this._add(i, animated);
            } else if (target < this.count) {
              for (let i = this.count - 1; i >= target; i--) this._remove(i, animated);
            }
            this.count = target;
          }
          _add(i, animated) {
            const chip = document.createElement('div');
            chip.className = `chip ${this.color}`;
            chip.style.bottom = `${i * 3}px`;
            chip.style.zIndex = i;
            this.el.querySelector('.stack-column').appendChild(chip);
            this.chips[i] = chip;
            if (animated) setTimeout(() => chip.classList.add('visible'), i * 30);
            else chip.classList.add('visible');
          }
          _remove(i, animated) {
            const chip = this.chips[i]; if (!chip) return;
            if (animated) {
              chip.classList.add('removing');
              setTimeout(() => chip.parentNode && chip.parentNode.removeChild(chip), 400);
            } else {
              chip.parentNode && chip.parentNode.removeChild(chip);
            }
            this.chips[i] = null;
          }
        }
        
        const CHIP_COLORS = ['blue','red','green','purple','orange','yellow','cyan','pink','lime','magenta'];
        /* Choose how cash → chip units is computed. We keep it simple & stable:
           - Make ~100–160 visible “chip units” at each player’s starting stack
           - Scale linearly with stack growth/decline so animations remain informative */
        function compute_denominator(initialCash) {
          // Make ~120 chips at start: denom ≈ initialCash / 120 (≥1)
          return Math.max(1, Math.round(initialCash / 120));
        }
        
        
        function getChipColorHex(colorName) {
            const colorMap = {
                'blue': '#3b82f6',
                'red': '#ef4444', 
                'green': '#22c55e',
                'purple': '#a855f7',
                'orange': '#f97316',
                'yellow': '#eab308',
                'cyan': '#06b6d4',
                'pink': '#ec4899',
                'lime': '#84cc16',
                'magenta': '#d946ef'
            };
            return colorMap[colorName] || '#1e40af'; // fallback to default blue
        }
                
        
        function ensureChipStacksForPlayer(player, index) {
            const card = document.getElementById(`player-${index}`);
            if (!card) return;
        
            //const color = CHIP_COLORS[index % CHIP_COLORS.length];
            const color = 'navy';
            const name = player.name;
            
            // In ensureChipStacksForPlayer function, comment out this section:
            // const nameElement = card.querySelector('.player-name');
            // if (nameElement) {
            //     nameElement.style.color = getChipColorHex(color);
            // }
        
            // Use GLOBAL denominator for all players
            const denom = getGlobalChipDenominator();
            
            let ui = playerChipUI.get(name);
        
            // Helper to distribute totalUnits over N stacks
            const splitUnits = (totalUnits, n) => {
                const per = Math.floor(totalUnits / n);
                const rem = totalUnits % n;
                return Array.from({ length: n }, (_, i) => per + (i < rem ? 1 : 0));
            };
        
            // Find fresh DOM nodes
            const grid = card.querySelector('.stacks-grid');
            const stackEls = grid ? grid.querySelectorAll('.chip-stack') : [];
            const deltaEl = document.getElementById(`delta-${index}`);
            if (!stackEls.length) return;
        
            if (!ui) {
                // First time: create stacks AND prime to current (no animation)
                const stacks = Array.from(stackEls, el => new ChipStack(el, color));
                const totalUnitsNow = Math.floor((player.chips || 0) / denom);
                const parts = splitUnits(totalUnitsNow, stacks.length);
                stacks.forEach((stack, i) => stack.setChipCount(parts[i], /*animated*/ false));
                playerChipUI.set(name, { stacks, color, denom, prevCash: player.chips ?? 0, deltaEl });
                return;
            }
        
            // UI exists: if old DOM disconnected, rebind but keep prior counts
            if (!ui.stacks.length || !ui.stacks[0].el.isConnected) {
                const prevCash = ui.prevCash ?? player.chips ?? 0;
                const prevUnits = Math.floor(prevCash / denom);
        
                const stacks = Array.from(stackEls, el => new ChipStack(el, color));
                const parts = splitUnits(prevUnits, stacks.length);
                stacks.forEach((stack, i) => stack.setChipCount(parts[i], /*animated*/ false));
        
                // Update references, keep prevCash but use GLOBAL denom
                ui.stacks = stacks;
                ui.deltaEl = deltaEl;
                ui.color = color;
                ui.denom = denom; // Use global denominator
                ui.prevCash = prevCash;
                playerChipUI.set(name, ui);
                return;
            }
        
            // UI exists and DOM still connected: update with global denom
            ui.denom = denom; // Ensure we're using the global denominator
        }



        
        
        function updateChipStacks(state) {
          if (!state?.players) return;
          
          // Get the actual starting chip amount from the game configuration
          const startingChips = [...initialChips.values()][0]; // All players start with same amount
          
          // Scale so starting amount = ~15 visual units, max possible (all chips) = 40 units
          const totalChipsInGame = [...initialChips.values()].reduce((a, b) => a + b, 0);
          const chipsPerUnit = totalChipsInGame / 40; // Winner with all chips = max height
          
          state.players.forEach((p, idx) => {
            ensureChipStacksForPlayer(p, idx);
            const ui = playerChipUI.get(p.name);
            if (!ui) return;
        
            const totalUnits = Math.max(1, Math.min(40, Math.floor((p.chips || 0) / chipsPerUnit)));
        
            const perStack = Math.floor(totalUnits / ui.stacks.length);
            const rem = totalUnits % ui.stacks.length;
        
            ui.stacks.forEach((stack, i) => {
              const units = perStack + (i < rem ? 1 : 0);
              stack.setChipCount(units, /*animated*/ true);
            });
        
            ui.prevCash = p.chips;
          });
        }
        
        let lastCurrentPlayer = null;

        function updateUtilityBoxes(gameState) {
            if (!gameState || !gameState.players) {
                console.log('No game state or players, clearing utility boxes');
                clearUtilityBoxes();
                return;
            }
            
            console.log('=== UTILITY BOX UPDATE DEBUG ===');
            
            // Log all players' MCP data for debugging
            gameState.players.forEach((player, idx) => {
                console.log(`Player ${idx} (${player.name}):`);
                console.log(`  handAnalysis: "${player.handAnalysis || 'EMPTY'}"`);
                console.log(`  monteCarloResult: "${player.monteCarloResult || 'EMPTY'}"`);
                console.log(`  opponentStats: "${player.opponentStats || 'EMPTY'}"`);
                console.log(`  isCurrentPlayer: ${player.isCurrentPlayer}`);
            });
            
            // Find the current player (highest priority)
            const currentPlayer = gameState.players.find(p => p.isCurrentPlayer);
            let displayPlayer = null;
            
            if (currentPlayer) {
                console.log(`Current player: ${currentPlayer.name}`);
                
                // Check if current player has ANY MCP data
                const hasHandAnalysis = currentPlayer.handAnalysis && currentPlayer.handAnalysis.trim() !== '';
                const hasMonteCarlo = currentPlayer.monteCarloResult && currentPlayer.monteCarloResult.trim() !== '';
                const hasOpponentStats = currentPlayer.opponentStats && currentPlayer.opponentStats.trim() !== '';
                
                console.log(`Current player MCP data: hand=${hasHandAnalysis}, monte=${hasMonteCarlo}, stats=${hasOpponentStats}`);
                
                if (hasHandAnalysis || hasMonteCarlo || hasOpponentStats) {
                    displayPlayer = currentPlayer;
                    console.log('Using current player data');
                } else {
                    console.log('Current player has no MCP data, looking for recent data...');
                    
                    // Look for most recent player with data (not the current player)
                    for (const player of gameState.players) {
                        if (player.name !== currentPlayer.name) { // Skip current player
                            const hasData = (player.handAnalysis && player.handAnalysis.trim() !== '') ||
                                          (player.monteCarloResult && player.monteCarloResult.trim() !== '') ||
                                          (player.opponentStats && player.opponentStats.trim() !== '');
                            
                            if (hasData) {
                                displayPlayer = player;
                                console.log(`Found recent data from: ${player.name}`);
                                break;
                            }
                        }
                    }
                }
            } else {
                console.log('No current player found');
            }
            
            // Update utility boxes
            const handAnalysisEl = document.getElementById('hand-analysis-content');
            const monteCarloEl = document.getElementById('monte-carlo-content');
            const opponentStatsEl = document.getElementById('opponent-stats-content');
            
            if (displayPlayer) {
                console.log(`Displaying data from: ${displayPlayer.name}`);
                
                handAnalysisEl.textContent = displayPlayer.handAnalysis || '';
                monteCarloEl.textContent = displayPlayer.monteCarloResult || '';
                opponentStatsEl.textContent = displayPlayer.opponentStats || '';
                
                console.log('Updated utility boxes successfully');
            } else {
                console.log('No player with MCP data found, clearing boxes');
                handAnalysisEl.textContent = '';
                monteCarloEl.textContent = '';
                opponentStatsEl.textContent = '';
            }
            
            console.log('=== END UTILITY BOX UPDATE ===');
        }
        
        function clearUtilityBoxes() {
            console.log('Clearing all utility boxes');
            document.getElementById('hand-analysis-content').textContent = '';
            document.getElementById('monte-carlo-content').textContent = '';
            document.getElementById('opponent-stats-content').textContent = '';
        }
        
        // Event streaming for utility boxes
        function startEventStream() {
            const eventSource = new EventSource('/api/game/events');
            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);
                if (data.type === 'utility_update') {
                    updateSingleUtilityBox(data.utility_type, data.content);
                }
            };
        }
        
        function updateSingleUtilityBox(type, content) {
            const element = document.getElementById(`${type.replace('_', '-')}-content`);
            if (element) {
                element.textContent = content;
            }
        }
        
        // Call this when the page loads
        startEventStream();
                                                
                
        // Track previous actions to avoid unnecessary updates
        const playerActionStates = new Map();
        
        function updateActionDisplay(player, index) {
            const actionDisplayEl = document.getElementById(`action-display-${index}`);
            if (!actionDisplayEl) return;
            
            // DEBUG: Log what we're getting
            console.log(`Player ${player.name}: action="${player.action}", active=${player.active}`);
            
            // Check if this player's action has actually changed
            const currentAction = player.action || '';
            const previousAction = playerActionStates.get(player.name) || '';
            
            if (currentAction === previousAction) {
                return; // No change, skip update
            }
            
            // Store the new action state
            playerActionStates.set(player.name, currentAction);
            
            // Remove all action type classes
            actionDisplayEl.className = 'last-action-display';
            
            if (!player.action || player.action === 'Waiting...' || player.action === '') {
                actionDisplayEl.classList.add('waiting');
                actionDisplayEl.textContent = 'Waiting for action...';
                return;
            }
            
            const action = player.action.toLowerCase();
            let displayText = player.action;
            let actionType = 'waiting';
            
            // Determine action type and format display text
            if (action.includes('fold')) {
                actionType = 'fold';
                displayText = 'FOLD';
            } else if (action.includes('check')) {
                actionType = 'check';
                displayText = 'CHECK';
            } else if (action.includes('call')) {
                actionType = 'call';
                const match = action.match(/call\s+\$?(\d+)/i);
                displayText = match ? `CALL $${match[1]}` : 'CALL';
            } else if (action.includes('bet')) {
                actionType = 'bet';
                const match = action.match(/bet\s+\$?(\d+)/i);
                displayText = match ? `BET $${match[1]}` : 'BET';
            } else if (action.includes('raise')) {
                actionType = 'raise';
                const match = action.match(/raise.*?to\s+\$?(\d+)|raise\s+\$?(\d+)/i);
                const amount = match ? (match[1] || match[2]) : null;
                displayText = amount ? `RAISE $${amount}` : 'RAISE';
            } else if (action.includes('all-in') || action.includes('all in')) {
                actionType = 'raise';
                displayText = 'ALL-IN';
            }
            
            actionDisplayEl.classList.add(actionType);
            actionDisplayEl.textContent = displayText;
        }
        
        function clearActionStates() {
            playerActionStates.clear();
        }


        function updateDisplay(state) {
            if (!state || state.error) {
                showError(state?.error || "Failed to load game state");
                return;
            }
            
            gameState = state;
            hideError();
            hideLoading();
            
            if (state.players && state.players.length > 0) {
                const startingChips = state.players[0].chips;
                const numPlayers = state.players.length;
                const maxChips = startingChips * numPlayers;
                const maxDigits = String(maxChips).length;
                const chipBoxWidth = maxDigits * 12 + 30;
                document.documentElement.style
                    .setProperty('--chip-count-width', chipBoxWidth + 'px');
            }
            
            animateNumber(document.getElementById('potAmount'), state.pot || 0);
            
            const boardContainer = document.getElementById('boardCards');
            boardContainer.innerHTML = '';
            const boardCards = state.board || [];
            
            for (let i = 0; i < 5; i++) {
                if (i < boardCards.length && boardCards[i]) {
                    boardContainer.appendChild(createCard(boardCards[i], true));
                } else {
                    boardContainer.appendChild(createCard('', true));
                }
            }
            
            const playersGrid = document.getElementById('playersGrid');

            // Only recreate if player count changed or no players exist
            const existingPlayerCards = playersGrid.children.length;
            const newPlayerCount = state.players ? state.players.length : 0;
            
            if (existingPlayerCards !== newPlayerCount) {
                // Player count changed, need to recreate
                playersGrid.innerHTML = '';
                clearActionStates(); // Clear tracking since we're recreating
                
                if (state.players) {
                    state.players.forEach((player, index) => {
                        const isDealer = index === state.dealerIndex;
                        const playerCard = createPlayerCard(player, index, isDealer, state);
                        playersGrid.appendChild(playerCard);
                    });
                }
            } else {
                // Same number of players, just update existing cards
                if (state.players) {
                    state.players.forEach((player, index) => {
                        const existingCard = document.getElementById(`player-${index}`);
                        if (existingCard) {
                            // Update active/folded state
                            existingCard.classList.toggle('folded', !player.active);
                            existingCard.classList.toggle('active', player.isCurrentPlayer);
                            
                            // Update dealer indicator
                            const dealerIndicator = existingCard.querySelector('.dealer-indicator');
                            const shouldShowDealer = index === state.dealerIndex;
                            if (shouldShowDealer && !dealerIndicator) {
                                const header = existingCard.querySelector('.player-header');
                                header.innerHTML += '<div class="dealer-indicator">D</div>';
                            } else if (!shouldShowDealer && dealerIndicator) {
                                dealerIndicator.remove();
                            }
                            
                            const cardsContainer = existingCard.querySelector('.player-cards');
                            if (cardsContainer) {
                              cardsContainer.innerHTML = '';
                              if (player.cards && player.cards.length > 0) {
                                player.cards.forEach(card => {
                                  const cardElement = createCard(card);
                                  cardsContainer.appendChild(cardElement);
                                });
                              } else {
                                // optional: show facedown backs if no cards yet
                                cardsContainer.appendChild(createCard(''));
                                cardsContainer.appendChild(createCard(''));
                              }
                            }
                            
                            // Update hand strength display if needed
                            const showHandStrength = ['Flop', 'Turn', 'River', 'Showdown', 'Complete'].includes(state.phase);
                            const handBox = existingCard.querySelector('.hand-box');
                            if (showHandStrength && player.hand && !handBox) {
                                const actionRow = existingCard.querySelector('.action-info-row');
                                actionRow.innerHTML += `<div class="hand-box">${player.hand}</div>`;
                            } else if (handBox) {
                                if (showHandStrength && player.hand) {
                                    handBox.textContent = player.hand;
                                } else if (!showHandStrength) {
                                    handBox.textContent = ''; // Clear content but keep the box
                                }
                            }
                            
                            // Update reasoning
                            const reasoningEl = existingCard.querySelector('.player-reasoning');
                            if (reasoningEl) {
                                const reasoningBubbles = createReasoningBubbles(player.reasoning || '');
                                reasoningEl.innerHTML = '<div class="reasoning-label">Decision:</div>' + reasoningBubbles;
                            }
                            
                            const planningEl = existingCard.querySelector('.planning-reasoning');
                            if (planningEl) {
                                const planningBubbles = createReasoningBubbles(player.planning || '');
                                planningEl.innerHTML = '<div class="reasoning-label">Planning:</div>' + planningBubbles;
                            }
                        }
                    });
                }
            }
            
            // Now update action displays (existing elements won't be destroyed)
            if (state.players) {
                state.players.forEach((player, index) => {
                    updateActionDisplay(player, index);
                });
            }
            
            // Record initial stacks exactly once (for stable chip scaling)
            if (initialChips.size === 0 && state?.players) {
              state.players.forEach(p => initialChips.set(p.name, p.chips || 0));
            }
            
            
            ensureInitials(state);
            updateBars(state);
            
            // NEW: drive chip stacks from real chip counts
            updateChipStacks(state);
            
            // *** REPLACE ONLY THIS SECTION BELOW ***
            const startBtn = document.getElementById('startHandBtn');
            const nextBtn = document.getElementById('nextActionBtn');
            const autoBtn = document.getElementById('autoPlayBtn');
            const stopBtn = document.getElementById('stopAutoBtn');
            
            if (state.isComplete) {
                startBtn.style.display = 'inline-block';
                startBtn.textContent = 'Start New Hand';
                nextBtn.style.display = 'none';
                autoBtn.style.display = 'none';
                stopBtn.style.display = 'none';
            } else if (state.phase && state.phase !== 'Ready to Start') {
                startBtn.style.display = 'none';
                if (isAutoPlaying) {
                    nextBtn.style.display = 'none';
                    autoBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-block';
                } else {
                    nextBtn.style.display = 'inline-block';
                    autoBtn.style.display = 'inline-block';
                    stopBtn.style.display = 'none';
                }
            }
            // Update utility boxes
            updateUtilityBoxes(state);
        }

        function showLoading() {
            const loadingEl = document.getElementById('loadingMessage');
            if (loadingEl) loadingEl.style.display = 'block';
            const nextBtn = document.getElementById('nextActionBtn');
            const startBtn = document.getElementById('startHandBtn');
            const autoBtn = document.getElementById('autoPlayBtn');
            if (nextBtn) nextBtn.disabled = true;
            if (startBtn) startBtn.disabled = true;
            if (autoBtn) autoBtn.disabled = true;
        }
        
        function hideLoading() {
            const loadingEl = document.getElementById('loadingMessage');
            if (loadingEl) loadingEl.style.display = 'none';
            const nextBtn = document.getElementById('nextActionBtn');
            const startBtn = document.getElementById('startHandBtn');
            const autoBtn = document.getElementById('autoPlayBtn');
            if (nextBtn) nextBtn.disabled = false;
            if (startBtn) startBtn.disabled = false;
            if (autoBtn) autoBtn.disabled = false;
        }

        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }
        
        async function autoPlay() {
            if (isAutoPlaying) return;
            
            isAutoPlaying = true;
            updateDisplay(gameState); // Refresh buttons
            addLogEntry("Auto play started - running until completion");
            
            try {
                while (isAutoPlaying && gameState && !gameState.isComplete) {
                    // Use the existing next action endpoint
                    const response = await fetch('/api/game/next', {
                        method: 'POST'
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Server error: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    
                    if (result.error) {
                        throw new Error(result.error);
                    }
                    
                    // Update display with each step
                    if (result.game_state) {
                        updateDisplay(result.game_state);
                        gameState = result.game_state;
                    }
                    
                    // Log the step
                    if (result.step_result) {
                        addLogEntry(result.step_result);
                    }
                    
                    // Check if hand is complete
                    if (result.complete) {
                        addLogEntry("Hand complete!");
                        
                        // Check if game should continue (more than 1 player with chips)
                        const activePlayers = gameState.players.filter(p => p.chips > 0);
                        if (activePlayers.length <= 1) {
                            addLogEntry("Game completed! Winner determined.");
                            stopAutoPlay();
                            break;
                        }
                        
                        // Start next hand
                        const nextHandResponse = await fetch('/api/game/start', {
                            method: 'POST'
                        });
                        
                        if (nextHandResponse.ok) {
                            const nextHandResult = await nextHandResponse.json();
                            // 8/29
                            if (nextHandResult.error) {
                              addLogEntry(nextHandResult.error);
                              // optionally surface a toast
                              showError(nextHandResult.error);
                              stopAutoPlay();
                              break;
                            }
                            // 8/29
                            updateDisplay(nextHandResult);
                            gameState = nextHandResult;
                            addLogEntry("New hand started");
                        } else {
                            stopAutoPlay();
                            break;
                        }
                    }
                    
                    // Small delay to see the updates
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                if (isAutoPlaying) {
                    addLogEntry("Auto play completed");
                    stopAutoPlay();
                }
                
            } catch (error) {
                console.error('Error during auto play:', error);
                showError(`Auto play failed: ${error.message}`);
                stopAutoPlay();
            }
        }
        
        function stopAutoPlay() {
            if (!isAutoPlaying) return;
            
            isAutoPlaying = false;
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }
            
            updateDisplay(gameState); // Refresh buttons
            addLogEntry("Auto play stopped");
        }

        function addLogEntry(message) {
            actionLog.push(message);
            updateActionLog();
        }

        function updateActionLog() {
            const logContainer = document.getElementById('actionLog');
            logContainer.innerHTML = '';
            
            const recentLog = actionLog.slice(-15);
            recentLog.forEach(entry => {
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                logEntry.textContent = entry;
                logContainer.appendChild(logEntry);
            });
            
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        function clearReasoningContent() {
            // Clear all planning and reasoning boxes
            const planningBoxes = document.querySelectorAll('.planning-reasoning');
            const reasoningBoxes = document.querySelectorAll('.player-reasoning');
            
            planningBoxes.forEach(box => {
                box.innerHTML = '<div class="reasoning-label">Planning:</div><div class="reasoning-empty">Waiting for decision...</div>';
            });
            
            reasoningBoxes.forEach(box => {
                box.innerHTML = '<div class="reasoning-label">Decision:</div><div class="reasoning-empty">Waiting for decision...</div>';
            });
        }

        async function startNewHand() {
            clearActionStates();
            clearUtilityBoxes();
            clearReasoningContent();
            showLoading();
            
            // FORCE CLEAR any cached display data
            lastCurrentPlayer = null;
            
            addLogEntry("Starting new hand...");
            
            try {
                const response = await fetch('/api/game/start', {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }
                
                const result = await response.json();
                // 8/29
                if (result.error) {
                  showError(result.error);
                  addLogEntry(result.error);
                  hideLoading();
                  return;
                }
                // 8/29
                updateDisplay(result);
                addLogEntry("New hand started - cards dealt");
                
            } catch (error) {
                console.error('Error starting hand:', error);
                showError(`Failed to start hand: ${error.message}`);
                hideLoading();
            }
        }

        async function nextAction() {
            showLoading();
            
            try {
                const response = await fetch('/api/game/next', {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.error) {
                    throw new Error(result.error);
                }
                
                updateDisplay(result.game_state);
                
                if (result.step_result) {
                    addLogEntry(result.step_result);
                }
                
                if (result.complete) {
                    addLogEntry("Hand complete!");
                }
                
            } catch (error) {
                console.error('Error executing next action:', error);
                showError(`Failed to execute action: ${error.message}`);
                hideLoading();
            }
        }

        async function resetGame() {
            showLoading();
            addLogEntry("Resetting game...");
            
            // Stop auto play if it's running
            stopAutoPlay();
            
            try {
                const response = await fetch('/api/game/reset', {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }
                
                gameState = null;
                actionLog = ["Game reset - ready to start new hand"];
                updateActionLog();
                
                document.getElementById('potAmount').textContent = "0";
                document.getElementById('boardCards').innerHTML = '';
                document.getElementById('playersGrid').innerHTML = '';
                
                document.getElementById('startHandBtn').style.display = 'inline-block';
                document.getElementById('startHandBtn').textContent = 'Start New Hand';
                document.getElementById('nextActionBtn').style.display = 'none';
                document.getElementById('autoPlayBtn').style.display = 'none';
                document.getElementById('stopAutoBtn').style.display = 'none';
                
                hideError();
                hideLoading();
                
            } catch (error) {
                console.error('Error resetting game:', error);
                showError(`Failed to reset game: ${error.message}`);
                hideLoading();
            }
        }

        updateActionLog();
    </script>
</body>
</html>